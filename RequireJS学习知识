RequireJS培训
	JavaScript模块化
		背景：
			随着前端页面越来越复杂，大量的业务逻辑及交互操作处理都在前端通过JavaScript代码实现。需要一个团队分工协作、进度管理、单元测试等等......开发者不得不使用软件工程的方法，管理网页的业务逻辑，即JavaScript模块化编程。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。
		问题：
			javascript不是一种模块化编程语言，它不支持"类"（class），当然也不支持"模块"（module）了。（ECMAScript标准第六版，将正式支持"类"和"模块"，但浏览器版本的兼容性还需要很长时间的路要走。）
		解决方案：
			由于JavaScript语言本身并没有给出一套模块化规范，因此就需要制定一套模块化的规范。大家都按照这种规范定义模块，按照这种规范引用模块。AMD（异步模块定义）就是这种规范。
	AMD
		简介：
			AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
		核心内容：
			所谓异步模块就是指定义的这些模块，会被浏览器异步加载。采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
		实现：
			RequireJS是实现了AMD规范的插件之一。
	RequireJS
		RequireJS解决了哪些问题？
			1.实现js文件的异步加载，避免网页失去响应；
			2.管理模块之间的依赖性，便于代码的编写和维护。
			示例：test1.html
				该示例中的加载各个模块方式存在问题：
					1.加载js的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长。尤其是这些文件保存在服务器时，会耗费很长时间发生请求拿到该文件。
					2.由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如例子的module1.js要在module2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。
			示例：test2.html
				该示例使用了RequireJS方式加载模块，解决了test1.html中存在的问题。
				说明：可以看到，test2中，执行模块1代码中alert时，body中的标签继续进行了渲染，后边的标签已经渲染出来了。而test1中，执行模块1代码中的alert时，baody中标签没有再进行渲染，而是阻塞在了加载模块的地方。这就是所谓的requireJS实现了代码的异步加载。
		RequireJS核心接口
			data-main
				作用：指定网页程序的主模块。
				用法：data-main是script标签属性，用在加载requireJS源码的script标签上。
				说明：require.js 在加载的时候会检查data-main 属性，如果设置了这个属性，就会获取属性值，根据属性值设置了文件路径，找到对应的主模块文件，然后异步加载这个文件。
				注意：data-main的值是入口程序文件的地址，可以是相对路径也可以是绝对路径；最终的文件名不用带.js扩展名，因为RequireJS会默认为加载一个js文件。
				示例：test3.html
			require()
				语法：require(['moduleA', 'moduleB', 'moduleC'],    function (moduleA, moduleB, moduleC){
　　　　// some code here
　　})
				作用：异步加载依赖的模块，将所有依赖的模块加载完成后，将各个模块返回值传入回调函数参数中，在回调函数中实现业务逻辑。
				参数1：['moduleA', 'moduleB', 'moduleC']
					说明：数组中每一项都是一个依赖的模块将会被异步加载。数组每一项都是一个模块的相对路径，通过这个路径，RequireJS找到对应文件然后异步加载该文件。
					异步加载这个文件的原理：创建一个script标签节点，将src设置为这个路径值，将script标签的async属性设置为true。
					注意1：模块对应的文件名不用写.js 扩展名，RequireJS默认都是js文件。
					注意2：数组每个元素表示的模块路径地址写法，与require.config()配置项中的baseUrl属性和paths属性有关，这部分详细介绍参考require.config()部分。
				参数2：function (moduleA, moduleB, moduleC){ // some code here  }
					该回调函数的每个参数都对应数组中每个模块的返回值。参数名可以随意设置。
				示例：test4.html
					说明：加载的jquery是没有返回值的，所以回调函数中没有给其对应一个参数。
			define()
				作用：定义AMD模块。
				用法一：简单的值对
					说明：如果一个模块仅含值对，没有任何依赖，则在define()中定义这些值对就好了
				用法二：函数式定义
					说明：如果一个模块没有任何依赖，但有一些内部方法和变量，或者需要做一些逻辑方面的处理。那么可以将这些放在一个函数中。
				用法三：存在依赖的函数式定义
					说明：如果模块存在依赖：则第一个参数是依赖的名称数组；第二个参数是函数，在模块的所有依赖加载完毕后，该函数会被调用来定义该模块，因此该模块应该返回一个定义了本模块的object。依赖关系会以参数的形式注入到该函数上，参数列表与依赖名称列表一一对应。
				示例：test5.html
					该示例展示了define的三种用法。
			require.config()
				作用：该函数主要用于配置模块加载的行为。
				用法：该配置一般都写在main文件的开头部分。
				语法：require.config({paths:{}, baseUrl : String, })
				paths属性：
					作用：指定各个模块的加载路径
					说明：paths属性是一个对象，每个对象的属性对应一个模块或者文件夹，属性的key标志着这个模块后边被加载时的名字，属性value标志着 这个模块真正的路径地址。
				baseUrl属性：
					作用：指定基目录，即：所有模块的查找根路径。
					说明：当加载纯.js文件(依赖字串以/开头，或者以.js结尾，或者含有协议http等)，不会使用baseUrl。
					默认值：如未显式设置baseUrl，则默认值是加载require.js的HTML所处的位置。如果用了data-main属性，则该路径就变成baseUrl。
					注意：paths属性中设置的路径地址也会受到baseUrl影响。
				shim属性：
					作用：为那些没有使用define()定义模块的插件设置依赖和导出变量名。
					说明：有些插件没有采用AMD规范，这时，如果我们项目中使用了这些插件，又想通过RequireJS依赖和管理这些模块时，就需要设置shim属性。
					用法：shim是一个对象，对象的每个属性对应一个插件名的路径地址，每个属性都是一个对象，一般情况包含两个设置deps（该插件依赖的模块名地址）和exports（表明这个模块外部调用时的名称；）。
				其它属性：map、packages、config等
					这些属性不是很常用，这里不做详细说明。有关这些属性的详细描述，可以参考官网API说明：http://www.requirejs.cn/docs/api.html#config
				示例：test6.html
					该示例展示了paths、baseUrl、shim的基本使用方法。
		重要的注意点：
			1.所有模块只会被加载执行一次，即使这个模块被多个模块依赖。
			2.一个文件一个模块
				 每个Javascript文件应该只定义一个模块，这是模块名-至-文件名查找机制的自然要求。多个模块会被优化工具组织优化，但你在使用优化工具时应将多个模块放置到一个文件中。
			3.路径小知识：./代表当前目录（可省略不写）
../代表上层目录
../../代表上层的上层目录，以此类推
/代表根目录
	ES6中模块
		这部分不做详细介绍，ES6中的模块功能完全可以取代现在的AMD，但是各个浏览器的兼容性是目前还不能完全取代RequireJS的硬伤。
		推荐一个比较好的网站，大家可以去了解：http://es6.ruanyifeng.com/#docs/module
	实战：解析RequireJS在TinyUI框架中的使用方法
JavaScript模块化
	背景：
		随着前端页面越来越复杂，大量的业务逻辑及交互操作处理都在前端通过JavaScript代码实现。需要一个团队分工协作、进度管理、单元测试等等......开发者不得不使用软件工程的方法，管理网页的业务逻辑，即JavaScript模块化编程。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。
	问题：
		javascript不是一种模块化编程语言，它不支持"类"（class），当然也不支持"模块"（module）了。（ECMAScript标准第六版，将正式支持"类"和"模块"，但浏览器版本的兼容性还需要很长时间的路要走。）
	解决方案：
		由于JavaScript语言本身并没有给出一套模块化规范，因此就需要制定一套模块化的规范。大家都按照这种规范定义模块，按照这种规范引用模块。AMD（异步模块定义）就是这种规范。
AMD
	简介：
		AMD是"Asynchronous Module Definition"的缩写，意思就是"异步模块定义"。
	核心内容：
		所谓异步模块就是指定义的这些模块，会被浏览器异步加载。采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。
	实现：
		RequireJS是实现了AMD规范的插件之一。
RequireJS
	RequireJS解决了哪些问题？
		1.实现js文件的异步加载，避免网页失去响应；
		2.管理模块之间的依赖性，便于代码的编写和维护。
		示例：test1.html
			该示例中的加载各个模块方式存在问题：
				1.加载js的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长。尤其是这些文件保存在服务器时，会耗费很长时间发生请求拿到该文件。
				2.由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如例子的module1.js要在module2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。
		示例：test2.html
			该示例使用了RequireJS方式加载模块，解决了test1.html中存在的问题。
			说明：可以看到，test2中，执行模块1代码中alert时，body中的标签继续进行了渲染，后边的标签已经渲染出来了。而test1中，执行模块1代码中的alert时，baody中标签没有再进行渲染，而是阻塞在了加载模块的地方。这就是所谓的requireJS实现了代码的异步加载。
	RequireJS核心接口
		data-main
			作用：指定网页程序的主模块。
			用法：data-main是script标签属性，用在加载requireJS源码的script标签上。
			说明：require.js 在加载的时候会检查data-main 属性，如果设置了这个属性，就会获取属性值，根据属性值设置了文件路径，找到对应的主模块文件，然后异步加载这个文件。
			注意：data-main的值是入口程序文件的地址，可以是相对路径也可以是绝对路径；最终的文件名不用带.js扩展名，因为RequireJS会默认为加载一个js文件。
			示例：test3.html
		require()
			语法：require(['moduleA', 'moduleB', 'moduleC'],    function (moduleA, moduleB, moduleC){
　　　　// some code here
　　})
			作用：异步加载依赖的模块，将所有依赖的模块加载完成后，将各个模块返回值传入回调函数参数中，在回调函数中实现业务逻辑。
			参数1：['moduleA', 'moduleB', 'moduleC']
				说明：数组中每一项都是一个依赖的模块将会被异步加载。数组每一项都是一个模块的相对路径，通过这个路径，RequireJS找到对应文件然后异步加载该文件。
				异步加载这个文件的原理：创建一个script标签节点，将src设置为这个路径值，将script标签的async属性设置为true。
				注意1：模块对应的文件名不用写.js 扩展名，RequireJS默认都是js文件。
				注意2：数组每个元素表示的模块路径地址写法，与require.config()配置项中的baseUrl属性和paths属性有关，这部分详细介绍参考require.config()部分。
			参数2：function (moduleA, moduleB, moduleC){ // some code here  }
				该回调函数的每个参数都对应数组中每个模块的返回值。参数名可以随意设置。
			示例：test4.html
				说明：加载的jquery是没有返回值的，所以回调函数中没有给其对应一个参数。
		define()
			作用：定义AMD模块。
			用法一：简单的值对
				说明：如果一个模块仅含值对，没有任何依赖，则在define()中定义这些值对就好了
			用法二：函数式定义
				说明：如果一个模块没有任何依赖，但有一些内部方法和变量，或者需要做一些逻辑方面的处理。那么可以将这些放在一个函数中。
			用法三：存在依赖的函数式定义
				说明：如果模块存在依赖：则第一个参数是依赖的名称数组；第二个参数是函数，在模块的所有依赖加载完毕后，该函数会被调用来定义该模块，因此该模块应该返回一个定义了本模块的object。依赖关系会以参数的形式注入到该函数上，参数列表与依赖名称列表一一对应。
			示例：test5.html
				该示例展示了define的三种用法。
		require.config()
			作用：该函数主要用于配置模块加载的行为。
			用法：该配置一般都写在main文件的开头部分。
			语法：require.config({paths:{}, baseUrl : String, })
			paths属性：
				作用：指定各个模块的加载路径
				说明：paths属性是一个对象，每个对象的属性对应一个模块或者文件夹，属性的key标志着这个模块后边被加载时的名字，属性value标志着 这个模块真正的路径地址。
			baseUrl属性：
				作用：指定基目录，即：所有模块的查找根路径。
				说明：当加载纯.js文件(依赖字串以/开头，或者以.js结尾，或者含有协议http等)，不会使用baseUrl。
				默认值：如未显式设置baseUrl，则默认值是加载require.js的HTML所处的位置。如果用了data-main属性，则该路径就变成baseUrl。
				注意：paths属性中设置的路径地址也会受到baseUrl影响。
			shim属性：
				作用：为那些没有使用define()定义模块的插件设置依赖和导出变量名。
				说明：有些插件没有采用AMD规范，这时，如果我们项目中使用了这些插件，又想通过RequireJS依赖和管理这些模块时，就需要设置shim属性。
				用法：shim是一个对象，对象的每个属性对应一个插件名的路径地址，每个属性都是一个对象，一般情况包含两个设置deps（该插件依赖的模块名地址）和exports（表明这个模块外部调用时的名称；）。
			其它属性：map、packages、config等
				这些属性不是很常用，这里不做详细说明。有关这些属性的详细描述，可以参考官网API说明：http://www.requirejs.cn/docs/api.html#config
			示例：test6.html
				该示例展示了paths、baseUrl、shim的基本使用方法。
	重要的注意点：
		1.所有模块只会被加载执行一次，即使这个模块被多个模块依赖。
		2.一个文件一个模块
			 每个Javascript文件应该只定义一个模块，这是模块名-至-文件名查找机制的自然要求。多个模块会被优化工具组织优化，但你在使用优化工具时应将多个模块放置到一个文件中。
		3.路径小知识：./代表当前目录（可省略不写）
../代表上层目录
../../代表上层的上层目录，以此类推
/代表根目录
ES6中模块
	这部分不做详细介绍，ES6中的模块功能完全可以取代现在的AMD，但是各个浏览器的兼容性是目前还不能完全取代RequireJS的硬伤。
	推荐一个比较好的网站，大家可以去了解：http://es6.ruanyifeng.com/#docs/module
实战：解析RequireJS在TinyUI框架中的使用方法
